---
title: "Pvalues Generator"
author: "Katriona Goldmann"
output: rmarkdown::html_document
---

```{r setup, include = FALSE, echo = FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      warning = FALSE, 
                      message = FALSE, 
                      fig.height = 7, 
                      fig.width=7, 
                      fig.align = "center")
library(knitr)
library(kableExtra)
source("https://gist.githubusercontent.com/KatrionaGoldmann/3d6dfd6aa4cc5c3940bb72dc49beae02/raw/26e78c78a7a9d096d695c708e8a45830a1d1121a/render_toc.R")
```


<img src="../logo.png" align="right" alt="" width="200" />

```{r toc, echo = FALSE}
render_toc("./pvalues_generator.rmd")
```

---

# Introduction 

This vignette provides an example for creating pvalues objects for the 
volcano3D pipeline using DESeq2 and limma. 

This example consists of a case study from the PEAC 
rheumatoid arthritis project (Pathobiology of Early Arthritis Cohort). 
The methodology has been published in 
['Lewis, Myles J., et al. "Molecular portraits of early rheumatoid arthritis 
identify clinical and treatment response phenotypes." Cell reports 28.9 (2019): 
2455-2470.'
(DOI: 10.1016/j.celrep.2019.07.091)](https://doi.org/10.1016/j.celrep.2019.07.091)
with an interactive web tool available at 
[https://peac.hpc.qmul.ac.uk](https://peac.hpc.qmul.ac.uk).  

## Getting Started

### Install from CRAN

*Not yet publicly available:*

```{r, eval = FALSE}
install.packages("volcano3D")
```

### Install from Github

```{r, eval = FALSE}
library(devtools)
install_github("KatrionaGoldmann/volcano3D")

library(volcano3D)
```

The sample data used in this vignette can be loaded from the 
[volcano3Ddata package](https://github.com/KatrionaGoldmann/volcano3Ddata). 
This is only possible after volcano3D is imported. 

```{r, eval=FALSE}
install.packages("volcano3Ddata")
```

---

## Setup

To create a pvalues data frame we require:

1. the txi or expression data with columns representing different samples and 
rows representing different variables
2. The sample data which contains information for each sample in rows. 

These can both be loaded from the syn_txi dataset in the volcano3Ddata package. 

```{r}
library(volcano3Ddata)
data("syn_txi")
```

Check the alignment and make sure there are only three possible contrasts (in 
this case three unique Pathotypes)

```{r}
if(! identical(syn_metadata$ID, colnames(syn_txi$abundance))){
    stop("mis-aligned")
}

if(length(levels(syn_metadata$Pathotype)) != 3){
    stop("The number of unique pathotypes must qual 3")
}

groups <- levels(syn_metadata$Pathotype)
contrasts <- c(paste(groups[1], groups[2], sep="-"), 
               paste(groups[2], groups[3], sep="-"), 
               paste(groups[3], groups[1], sep="-"))
```

Our comparisons of interest are set up as: `r print(paste(contrasts, collapse=", "))`

In this vignette we will outline two methods to determine the differential
gene expression: 

1. [DESeq](#deseq)
2. [Limma-voom](#limma)


# DESeq method {#deseq}

Use the DESeq package to calculate the differential expression between groups. 
The vignette for this package can be found [here](http://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html)

```{r}
library(DESeq2)
dds = DESeqDataSetFromTximport(txi = syn_txi, 
                               colData = syn_metadata, 
                               design = ~Pathotype+Batch+Gender)

dds_DE <- DESeq(dds)
dds_LRT <- DESeq(dds, test = "LRT", reduced = ~Batch+Gender, parallel = TRUE) 
```

Output the results into one dataframe. First get the results for each 
contrast:

```{r}
Pvals_DESeq_DE <- lapply(contrasts, function(x){
    vars <- unlist(strsplit(x, split="-"))
    out <- results(dds_DE, contrast=c("Pathotype", vars))
    out <- out[match(rownames(syn_txi$counts), rownames(out)), ]
    out <- out[,c("pvalue", "padj", "log2FoldChange")]
})
```

Then get the multi-group test results. In this case we use the Likelihood ratio 
test - this compares the model using `~Pathotype+Batch+Gender` to the reduced 
model using `~Batch+Gender`. 

```{r}
LRT <- results(dds_LRT, parallel=TRUE)[, c("pvalue", "padj", "log2FoldChange")]
LRT <- LRT[match(rownames(syn_txi$counts), rownames(LRT)), ]
```

The results can then be combined into one pvalues data frame: 

```{r}
Pvals_DESeq <- cbind(Pvals_DESeq_DE[[1]], 
                     Pvals_DESeq_DE[[2]], 
                     Pvals_DESeq_DE[[3]], 
                     LRT)
colnames(Pvals_DESeq) <- c(paste(rep(contrasts, each=3), 
                                 rep(colnames(Pvals_DESeq_DE[[1]]), 3)), 
                           paste("LRT", colnames(LRT)))

Pvals_DESeq <- data.frame(Pvals_DESeq[complete.cases(Pvals_DESeq), ], 
                          check.names = FALSE)
```

Now we can inspect:

```{r}
head(Pvals_DESeq) %>%
    kable() %>%
    kable_styling(font_size=8.7)
```

# Limma-voom method {#limma}

Use the Limma package to calculate the differential expression between groups. 
The limma vignette can be found 
[here](https://bioconductor.org/packages/release/bioc/vignettes/limma/inst/doc/usersguide.pdf)
and limma-voom vignette 
[here](https://ucdavis-bioinformatics-training.github.io/2018-June-RNA-Seq-Workshop/thursday/DE.html).

```{r}
library(limma)
library(edgeR)

syn_tpm = syn_txi$counts

# build the design matrix and contrast matrix
design <- model.matrix(~ 0 + syn_metadata$Pathotype + syn_metadata$Batch)  
colnames(design) <- gsub("syn_metadata\\$Pathotype", "", colnames(design))
colnames(design) <- gsub("syn_metadata\\$Batch", "", colnames(design))

contrast.matrix <- makeContrasts(
    paste0(colnames(design)[1] , "-", colnames(design)[2]),
    paste0(colnames(design)[2] , "-", colnames(design)[3]),
    paste0(colnames(design)[3] , "-", colnames(design)[1]),
    levels = design)

# filter data and normalise
dge <- DGEList(counts = syn_tpm)     
keep <- filterByExpr(dge, design)
dge <- dge[keep, , keep.lib.sizes=FALSE]
dge <- calcNormFactors(dge)

# filter expression data to match
syn_tpm_limma = data.frame(syn_tpm[keep, ])

# voom
v <- voom(dge, design, plot=FALSE)
fit1 <- lmFit(v, design)
fit <- contrasts.fit(fit1, contrast.matrix) 
fit <- eBayes(fit)
```

Now we can get the model fit results. 

```{r}
contrasts <- colnames(coefficients(fit))

Pvals_limma_DE <- lapply(contrasts, function(x){
    id = which(colnames(coefficients(fit)) == x)
    
    out <- topTable(fit, adjust.method = "fdr", coef= id, number=Inf, 
                    sort.by="none")
    rownames(out) <- make.names(out$ID, unique=T)
    out <- out[,c("P.Value", "adj.P.Val", "logFC")]
    colnames(out) <- c("pvalue", "padj", "log2FoldChange")
    out
})

Pvals_overall <- topTable(fit, coef=1:3, adjust.method="fdr", number=Inf, 
                          sort.by="none")[,c("P.Value", "adj.P.Val")]
colnames(Pvals_overall) <- c("pvalue", "padj")
```

The results can then be combined into one pvalues data frame: 

```{r}
Pvals_limma <- cbind(Pvals_limma_DE[[1]], 
                     Pvals_limma_DE[[2]], 
                     Pvals_limma_DE[[3]], 
                     Pvals_overall)

colnames(Pvals_limma) <- c(paste(rep(contrasts, each=3), 
                                 rep(colnames(Pvals_limma_DE[[1]]), 3)), 
                           paste("Overall", colnames(Pvals_overall)))
```

Now we can inspect:

```{r, echo=FALSE}
head(Pvals_limma) %>%
    kable() %>%
    kable_styling(font_size=8.7)
```

# Using the Pvalues Objects

Both the deseq and limma-voom pvalues objects can then be used to create various
plots with the volcano3D package as outlined in the [vignette](https://katrionagoldmann.github.io/volcano3D/articles/Vignette.html). 

## With DESeq

```{r}
syn_counts = syn_txi$counts[intersect(rownames(Pvals_DESeq), 
                                      rownames(syn_txi$counts)), ]

syn_polar_deseq <- polar_coords(sampledata = syn_metadata,
                          contrast = "Pathotype",
                          pvalues = Pvals_DESeq,
                          expression = syn_rld,
                          p_col_suffix = "pvalue",
                          padj_col_suffix = "padj",
                          fc_col_suffix = "log2FoldChange",
                          multi_group_prefix = "LRT",
                          non_sig_name = "Not Significant",
                          significance_cutoff = 0.01,
                          label_column = NULL,
                          fc_cutoff = 0.1)
```

```{r}
radial_plotly(polar = syn_polar_deseq, 
              label_rows = c("SLAMF6", "PARP16", "ITM2C"))
```

```{r}
p <- volcano3D(syn_polar_deseq,
               label_rows = c("SLAMF6", "PARP16", "ITM2C"),
               label_size = 10,
               xy_aspectratio = 1,
               z_aspectratio = 0.9)

p %>% plotly::layout(legend = list(x = 100, y = 0.5))
```

## With Limma

The only difference here is we chanfe the multi_group_prefix to "Overall" and 
remove the fold change paramtere. 

```{r}
syn_polar_limma <- polar_coords(sampledata = syn_metadata,
                          contrast = "Pathotype",
                          pvalues = Pvals_limma,
                          expression = syn_tpm_limma,
                          p_col_suffix = "pvalue",
                          padj_col_suffix = "padj",
                          fc_col_suffix = NULL,
                          multi_group_prefix = "Overall",
                          non_sig_name = "Not Significant",
                          significance_cutoff = 0.01,
                          label_column = NULL,
                          fc_cutoff = 0.1)
```

```{r}
radial_plotly(polar = syn_polar_limma, 
              label_rows = c("SLAMF6", "PARP16", "ITM2C"))
```

```{r}
p <- volcano3D(syn_polar_limma,
               label_rows = c("SLAMF6", "PARP16", "ITM2C"),
               label_size = 10,
               xy_aspectratio = 1,
               z_aspectratio = 0.9)

p %>% plotly::layout(legend = list(x = 100, y = 0.5))
```